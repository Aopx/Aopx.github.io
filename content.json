{"meta":{"title":"Aopx's blog","subtitle":"积累点点滴滴","description":"Java","author":"Kyh","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-07T11:13:11.000Z","updated":"2018-05-07T11:14:48.984Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-07T11:10:24.000Z","updated":"2018-05-07T11:12:06.605Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"左耳听风ARTS第一周","slug":"左耳听风第一周-1","date":"2019-04-08T08:38:06.000Z","updated":"2019-04-08T08:40:21.336Z","comments":true,"path":"2019/04/08/左耳听风第一周-1/","link":"","permalink":"http://yoursite.com/2019/04/08/左耳听风第一周-1/","excerpt":"","text":"ARTS第一周 每周完成一个ARTS：每周至少做一个LeetCode的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章 Algorithm【题目】两数之和 【题意】给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 算法能力太差了，看着答案来理解都有点吃力，以后要加强补下基础和算法 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i = 0; i &lt; nums.length; i++)&#123; for(int j = i + 1; j &lt; nums.length; j++)&#123; if(nums[j] == target - nums[i])&#123; return new int[] &#123;i,j&#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; Reviewhttps://medium.com/m-a-science/utilize-deal-crm-software-to-improve-the-m-a-process-637d3b3be762 这篇文章大致讲述的是一个Deal CRM与传统CRM的系统的区别。Deal CRM功能： 拖放文件上传 权限 请求选项 全文搜索 智能分析 Tiphttps://www.cnblogs.com/larryzeal/p/5799195.html这周开始学习SpringBoot share费曼笔记法 阅读一篇文章或者书籍后，然后在一章节或者一小段写下自己的感想或者用自己的话写出内容讲述的是什么。","categories":[],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"MySQL基础","slug":"MySQL基础","date":"2018-01-20T14:09:28.000Z","updated":"2018-11-12T13:24:39.572Z","comments":true,"path":"2018/01/20/MySQL基础/","link":"","permalink":"http://yoursite.com/2018/01/20/MySQL基础/","excerpt":"SQL语法在命令行中输入 mysql -uroot -p 然后输入密码 进入mysql， 注意： SQL语句以分号结尾的 MySQL不区分大小写，但建议使用大写","text":"SQL语法在命令行中输入 mysql -uroot -p 然后输入密码 进入mysql， 注意： SQL语句以分号结尾的 MySQL不区分大小写，但建议使用大写 SQL语句分类 DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等； 创建、删除、修改：库、表结构！！！ DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）； 增、删、改：表记录 DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别； DQL*（Data Query Language）：数据查询语言，用来查询记录（数据）。 DDL:数据库或表的结构操作查看所有数据库： 1SHOW DATABASES; 使用数据库： 1USE 数据库名; 创建数据库： 1CREATE DATABASE [IF NOT EXISTS] 数据库名 [CHARSET=utf8] 删除数据库： 1DROP DATABASE 数据库名; 修改数据库编码: 1ALTER DATABASE mydb1 CHARACTER SET utf8 数据类型(列类型) INT:整型 DOUBLE：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99； DECIMAL：浮点型，在表单钱方面使用该类型，因为不会出现精度缺失问题； CHAR：固定长度字符串类型； char(255)，数据的长度不足指定长度，补足到指定长度！ VARCHAR：可变长度字符串类型； varchar(65535), zhangSan TEXT(CLOB)：字符串类型； DATE：日期类型，格式为：yyyy-MM-dd； TIME：时间类型，格式为：hh:mm:ss TIMESTAMP：时间戳类型； DATETIME:混合日期和时间值，格式为:YYYYMMDD HHMMSS. 创建表123456CREATE TABLE [IF NOT EXISTS] 表名(ITCAST_0001 列名 列类型, 列名 列类型, ... 列名 列类型); 查看当前数据库中所有表名称： 1SHOW TABLES; 查看指定表的创建语句： 1SHOW CREATE TABLE 表名; 查看表结构： 1DESC 表名; 删除表： 1DROP TABLE 表名; 修改表： 1前缀：ALTER TABLE 表名 修改之添加列： 12345ALTER TABLE 表名 ADD ( 列名 列类型, 列名 列类型, ... ); 修改之修改列类型(如果被修改的列已存在数据，那么新的类型可能会影响到已存在数据)： 1ALTER TABLE 表名 MODIFY 列名 列类型; 修改之修改列名： 1ALTER TABLE 表名 CHANGE 原列名 新列名 列类型; 修改之删除列： 1ALTER TABLE 表名 DROP 列名; 修改表名称： 1ALTER TABLE 原表名 RENAME TO 新表名; DML：对表的记录进行更新（增、删、改) 插入数据 1INTERT INTO 表名(列名1,列名2, ...) VALUES(列值1, 列值2, ...); 修改数据 1UPDATE 表名 SET 列名1=列值1, 列名2=列值2, ... [WHERE 条件] 运算符 1=、!=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=、BETWEEN...AND、IN(...)、IS NULL、NOT、OR、AND 1delete from 表名 (where 条件) 不加where条件时会删除表中所有的记录,一般数据库都有备份 DCL：对用户的创建，及授权！一个项目创建一个用户，一个项目对应的数据库只有一个! 这个用户只能对这个数据库有权限，其他数据库你就操作不了！ 创建用户 1CREATE USER 用户名@IP地址 IDENTIFIED BY &apos;密码&apos;; 用户只能在指定的IP地址上登录 1CREATE USER 用户名@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;; 用户可以在任意IP地址上登录 给用户授权 1GRANT 权限1, … , 权限n ON 数据库.* TO 用户名@IP地址 权限、用户、数据库给用户分派在指定的数据库上的指定的权限例如；GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON mydb1.* TO user1@localhost; 给user1用户分派在mydb1数据库上的create、alter、drop、insert、update、delete、select权限 1GRANT ALL ON 数据库.* TO 用户名@IP地址; 给用户分派指定数据库上的所有权限 撤销授权 1REVOKE 权限1, … , 权限n ON 数据库.* FROM 用户名@IP地址; 撤消指定用户在指定数据库上的指定权限例如；REVOKE CREATE,ALTER,DROP ON mydb1.* FROM user1@localhost; 撤消user1用户在mydb1数据库上的create、alter、drop权限 查看权限 1SHOW GRANTS FOR 用户名@IP地址 查看指定用户的权限 删除用户 1DROP USER 用户名@IP地址 DQL：对表的记录的查询查看所有列： 1SELECT * FROM 表名 查看指定列： 1SELECT 列1 [, 列2, ... 列N] FROM 表名; 完全重复的记录只一次： 1SELECT DISTINCT * | 列1 [, 列2, ... 列N] FROM 表名; 列运算(数量类型的列可以做加、减、乘、除运算): 1SELECT 列*1.5 FROM 表名; 1SELECT 列1+列2 FROM 表名; 注意：如果和null运算就会变null，要使用ifnull(列名1,0) 0替换null 字符串类型可以做连续运算 1SELECT CONCAT(&apos;$&apos;, 列名) FROM 表名; 给列名起别名: 1select 列名1 (as) 别名1,列名2 (as) 别名2 from 表名； 条件查询 1.条件查询。在后面添加where指定条件: 1select * from 表名 where 列名＝指定值; 2.模糊查询：当你想查询所有姓张的记录。用到关键字like。eg: 1select * from 表名 where 列名 like &apos;张_&apos;; (_代表匹配任意一个字符，％代表匹配0～n个任意字符)。 排序 1SELECT * FROM WHERE 表名 ORDER BY 列名 ASC; 降序 1SELECT * FROM WHERE 表名 ORDER BY 列名 DESC; 聚合函数 聚合函数用来做某列的纵向运算。1) COUNT 1SELECT COUNT(*) FROM 表名; –&gt; 计算emp表中所有列都不为NULL的记录的行数 1SELECT COUNT(列名) FROM 表名; –&gt; 云计算表中列不为NULL的记录的行数2) MAX 1SELECT MAX(列名) FROM 表名; –&gt; 查询最高列3) MIN 1SELECT MIN(列名) FROM 表名; –&gt; 查询最低列4) SUM 1SELECT SUM(列名) FROM 表名; –&gt; 查询列名合5) AVG 1SELECT AVG(列名) FROM 表名; –&gt; 查询平均 分组查询分组查询的信息都是组的信息，不能查到个人的信息，其中查询组的信息是通过聚合函数得到的。 语法： 1select 分组列名，聚合函数1,聚合函数2 from 表名 group by 该分组列名； 其中分组列名需要的条件是该列名中有重复的信息。 分组查询前，还可以通过关键字where先把满足条件的人分出来，再分组。语法为: 1select 分组列，聚合函数 from 表名 where 条件 group by 分组列； 分组查询后，也可以通过关键字having把组信息中满足条件的组再细分出来。语法为: 1select 分组列，聚合函数 from 表名 where 条件 group by 分组列 having 聚合函数或列名(条件)； limit子句 LIMIT用来限定查询结果的起始行，以及总行数。 例如：查询起始行为第5行，一共查询3行记录 1SELECT * FROM 表名LIMIT 4, 3; (下标从0开始) –&gt; 其中4表示从第5行开始，其中3表示一共查询3行。即第5、6、7行记录。","categories":[{"name":"MySQL基础","slug":"MySQL基础","permalink":"http://yoursite.com/categories/MySQL基础/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Java面向对象总结","slug":"Java面向对象总结","date":"2017-12-06T14:31:03.000Z","updated":"2018-11-12T12:52:10.980Z","comments":true,"path":"2017/12/06/Java面向对象总结/","link":"","permalink":"http://yoursite.com/2017/12/06/Java面向对象总结/","excerpt":"Java面向对象总结两个重要概念 : 类(class)和对象(object，也被称为实例) 三大特征：封装 继承 多态 类：类是一组相关的属性和行为的集合，类一般都是泛指某一种事物，是一个抽象的概念 对象：就是该类事物的具体体现， 具体存在的实体","text":"Java面向对象总结两个重要概念 : 类(class)和对象(object，也被称为实例) 三大特征：封装 继承 多态 类：类是一组相关的属性和行为的集合，类一般都是泛指某一种事物，是一个抽象的概念 对象：就是该类事物的具体体现， 具体存在的实体 类：学生 对象 ： 张三、李四、kyh 定义一个类成员变量+成员方法 通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。1.导包：也就是指出需要使用的类，在什么位置。import包名称.类名称；import cn.itcast.daye6.demoe1.Student；对于和当前类属于同一个包的情况，可以省略导包语句不写。2.创建，格式：类名称 对象名 = new 类名称（）；Student stu = new Student（）；3.使用，分为两种情况：使用成员变量：对象名.成员变量名使用成员方法：对象名.成员方法名（参数） 12345678910111213141516171819202122232425262728293031323334353637383940public class Student &#123; //定义变量 //学号 int id; //姓名 String name; //性别 char sex; //年龄 int age; //定义方法 //学习的方法 public void study() &#123; System.out.println(name+\"我爱学习\"); &#125; //吃饭的方法 public void eat() &#123; System.out.println(name+\"饿了就吃饭\"); &#125; public static void main(String[] args) &#123; // TODOAuto-generated method stub //创建一个对象 //格式 ： 类名 对象名 = new 类名(); Student s = new Student(); //通过对象名.变量名的方式使用成员变量 s.id=12; s.name=\"kyh\"; s.sex='男'; s.age=19; System.out.println(s.id); System.out.println(s.name); System.out.println(s.sex); System.out.println(s.age); //通过对象名.方法名(...)的方式调用方法 s.study(); s.eat(); &#125;&#125; 方法重载发生的条件 发生在同一个类中. 方法名相同 参数列表不同(类型，个数，顺序) 成员变量和局部变量成员变量：写在类体的里面，方法体的外面，声明时可以不进行初始化值，可以被本类或其他类的方法进行调用。局部变量：写在方法体的里面，声明时必须进行初始化，只能在声明局部变量的方法内进行调用。 封装什么是封装？ 封装指的是隐藏对象的属性和实现的细节,提供公共方式来让外部访问 封装的好处： 隐藏类的实现细节 提高安全性 便于修改，提高代码的可维护性 private是封装的一种体现。​ 封装：类，方法，private修饰成员变量 private关键字(1)私有的意义，可以修饰成员变量和成员方法​ (2)特点：​ 被private修饰的后的成员只能在本类中被访问​ (3)private的应用：​ 以后再写一个类的时候：​ 把所有的成员变量给private了​ 提供对应的getXxx()/setXxx()方法 构造方法(1)作用：用于对对象的数据进行初始化​ (2)格式： ​ A:方法名和类名相同​ B:没有返回值类型，连void都不能有​ C:没有返回值(3)构造方法的注意事项​ A:如果我们没写构造方法，系统将提供一个默认的无参构造方法​ B:如果我们给出了构造方法，系统将不再提供默认构造方法​ 如果这个时候，我们要使用无参构造方法，就必须自己给出。​ 推荐：永远手动自己给出无参构造方法。(4)给成员变量赋值的方式​ A:setXxx()​ B:带参构造方法 this关键字​ (1)代表当前类的引用对象​ 记住：哪个对象调用方法，该方法内部的this就代表那个对象​ (2)this的应用场景：​ A:解决了局部变量隐藏成员变量的问题 Static存放在方法区里 static可以修饰变量，被static修饰的变量叫做静态变量，程序运行时静态变量存放在方法区里面，因此，静态变量在类加载阶段赋值，并且只赋值一次。 静态方法​ 可以使用“类名.”方式调用.也可以用“引用.”，即使用的是“引用.”，底层还是用的“类名.”​ 静态方法中不能直接访问非静态数据.​ 静态方法中不能使用this 什么是代码块？使用{}括起来的代码被称为代码块，根据其位置和声明的不同可以分为下面4种： 局部代码块，在方法中出现，限定变量生命周期，及早释放，提高内存利用率 构造代码块，在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 静态代码块， 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动。 同步代码块 ？？？ 静态语句块中的内容只会执行一次 继承Java通过extends关键字来实现继承 继承描述的是两个类之间的关系，被继承的类叫做父类，继承的类叫做子类 继承的好处：​ A:提高了代码的复用性​ B:提高了代码的维护性​ C:让类与类产生了一个关系，是多态的前提 继承的弊端：​ A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。​ 原则：低耦合，高内聚。​ 耦合：类与类的关系​ 内聚：自己完成某件事情的能力 ​ B:打破了封装性 Java中继承的特点​ A:Java中类只支持单继承​ B:Java中可以多层(重)继承(继承体系) 如何使用extends来实现继承关系？[修饰符列表] class 子类 extends 父类名{ ​ 类体； } 继承的注意事项：​ A:子类不能继承父类的私有成员(成员方法和成员变量)​ B:子类不能继承父类的构造方法，但是可以通过super去访问​ C:不要为了部分功能而去继承 什么是super?super代表的是当前子类对象中的父类型特征。 如果父类和子类都有一个name属性， 想在子类中访问父类中的name属性，就要调用super关键字 子类重写了父类的某个方法，子类需要调用 这个方法 就要使用super 注意：super不能用在静态方法中。 super和this的对比 this和super分别代表什么 this:代表当前对象的引用 super:代表的是当前子类对象中的父类型特征 this和super的使用区别 调用成员变量 this.成员变量： 调用本类的成员变量 super.成员变量： 调用父类的成员变量 调用构造方法 this(…) ：调用本类的构造方法 super(…)：调用父类的构造方法 调用成员方法 this.成员方法：调用本类的成员方法 super.成员方法：调用父类的成员方法 Java继承中的成员关系​ A:成员变量​ a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单​ b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?​ 子类的方法访问变量的查找顺序：​ 在子类方法的局部范围找，有就使用。​ 在子类的成员范围找，有就使用。​ 在父类的成员范围找，有就使用。​ 找不到，就报错。​ B:构造方法​ a:子类的构造方法默认会去访问父类的无参构造方法​ 是为了子类访问父类数据的初始化​ b:父类中如果没有无参构造方法，怎么办?​ 子类通过super去明确调用带参构造​ 子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造​ 让父类提供无参构造​ C:成员方法​ a:子类的成员方法和父类中的成员方法名称不一样，这个太简单​ b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?​ 通过子类对象访问一个方法的查找顺序：​ 在子类中找，有就使用​ 在父类中找，有就使用​ 找不到，就报错 什么是重写？重写，也叫做覆盖，当父类中的方法无法满足子类需求时，子类可以将父类的方法进行重写编写来满足需求。比如孩子继承了父亲的房子，可以将房子重新装修。方法重写的条件： 两个类必须是继承关系 必须具有相同的方法名，相同的返回值类型，相同的参数列表. 重写的方法不能比被重写的方法拥有更低的访问权限。 重写的方法不能比被重写的方法抛出更宽泛的异常。(关于异常后面的章节再讲。) 私有的方法不能被重写。 构造方法无法被重写，因为构造方法无法被继承。 静态的方法不存在重写。 重写指的是成员方法，和成员变量无关。 final关键字final 可以修饰类 、 方法、 变量 特点： final 可以修饰类 ，该类不能被继承 final 可以修饰方法，不能被重写 final 可以修饰变量，是一个常量 A:局部变量​ a:基本类型 值不能发生改变​ b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的​ B:初始化时机​ a:只能初始化一次。​ b:常见的给值​ 定义的时候。(推荐)​ 构造方法中。 多态(掌握)​ (1)同一个对象在不同时刻体现出来的不同状态。​ (2)多态的前提：​ A:有继承或者实现关系。​ B:有方法重写。​ C:有父类或者父接口引用指向子类对象。 ​ 多态的分类：​ 1234567891011121314a:具体类多态 class Fu &#123;&#125; class Zi extends Fu &#123;&#125; Fu f = new Zi();b:抽象类多态 abstract class Fu &#123;&#125; class Zi extends Fu &#123;&#125; Fu f = new Zi();c:接口多态 interface Fu &#123;&#125; class Zi implements Fu &#123;&#125; Fu f = new Zi(); ​ 多态的好处：​ A:提高代码的维护性(继承体现)​ B:提高代码的扩展性(多态体现) 多态中的转型​ A:向上转型​ 从子到父​ B:向下转型​ 从父到子 接口interface关键字 接口只能出现常量和抽象方法 接口中没有构造方法，因此不能创建对象 接口支持多继承 一个类可以实现多个接口 好处： 可以使项目分层 降低了代码之间的耦合度，提高了代码的可插拔性","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"Java代码块","slug":"Java代码块","date":"2017-11-15T15:09:28.000Z","updated":"2018-11-12T12:51:05.626Z","comments":true,"path":"2017/11/15/Java代码块/","link":"","permalink":"http://yoursite.com/2017/11/15/Java代码块/","excerpt":"我们来学学代码块用{ }括起来的就叫做代码块，根据其位置和声明不同，分为4大块 局部代码块，在方法中出现，限定变量生命周期，及早释放，提高内存利用率 构造代码块，在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 静态代码块， 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动。 同步代码块(多线程部分的)","text":"我们来学学代码块用{ }括起来的就叫做代码块，根据其位置和声明不同，分为4大块 局部代码块，在方法中出现，限定变量生命周期，及早释放，提高内存利用率 构造代码块，在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 静态代码块， 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动。 同步代码块(多线程部分的) 1234567891011121314151617181920212223242526272829303132333435363738394041package com.kroy.Block;class Student&#123; //静态代码块:只会执行一次 static&#123; System.out.println(\"我是学生类的静态代码块\"); &#125; //构造方法 public Student()&#123; System.out.println(\"构造方法\"); &#125; //构造代码块 &#123; System.out.println(\"构造代码块\"); &#125;&#125;public class BlockTest01 &#123; public static void main(String[] args) &#123; //局部代码块 &#123; int x = 10; System.out.println(x); &#125; Student s = new Student(); Student s1 = new Student(); &#125;&#125; 输出结果： 12345610我是学生类的静态代码块构造代码块构造方法构造代码块构造方法 1.静态代码块，随着类加载而加载,且只执行一次2.构造代码块，每创建一个对象就会执行一次，优先于构造方法执行3.构造方法，每创建一个对象就会执行一次 静态代码块、构造代码块、构造方法的执行顺序？静态代码块 &gt; 构造代码块&gt;构造方法","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":" Java 数组","slug":"Java-数组","date":"2017-11-14T15:09:28.000Z","updated":"2018-05-07T13:08:41.032Z","comments":true,"path":"2017/11/14/Java-数组/","link":"","permalink":"http://yoursite.com/2017/11/14/Java-数组/","excerpt":"数组 数组是相同类型的数据按顺序组成的一种引用数据类型 数组是用来存储固定大小的同类型元素。","text":"数组 数组是相同类型的数据按顺序组成的一种引用数据类型 数组是用来存储固定大小的同类型元素。 数组声明 语法格式 数据类型[] 数组名;int [] a; 创建数组 Java语言使用new操作符来创建数组int[] myArray =new int[10] ;还可以使用如下的方式创建数组int[] myArray = {1,2,3,4,5,6,7,8,9,10};注意：数组长度必须指定 实例 123456789101112131415161718192021222324252627282930313233343536373839 int[] a = new int[5];//使用Scanner 从键盘获取值Scanner sc=new Scanner(System.in);//分别存储输入的数for(int i=0;i&lt;a.length;i++)&#123; System.out.println(\"请输入元素\"+(i+1)); a[i]=sc.nextInt();&#125;System.out.println(\"原数组排序：\"); //输出数组的排序for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+\" \");&#125;//冒泡排序int temp;for(int i=0;i&lt;a.length-1;i++) &#123; for(int j=0;j&lt;a.length-i-1;j++) &#123; if(a[j]&lt;a[j+1]) &#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125;&#125;System.out.println();for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i]+\" \");&#125;System.out.println();for(int n:a) &#123; System.out.print(n+\" \");&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]}]}