{"meta":{"title":"Aopx的博客","subtitle":"积累点点滴滴","description":"学生、JAVA入门","author":"LK","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java面向对象总结","slug":"Java面向对象总结","date":"2017-12-06T14:31:03.000Z","updated":"2017-12-06T14:34:11.261Z","comments":true,"path":"2017/12/06/Java面向对象总结/","link":"","permalink":"http://yoursite.com/2017/12/06/Java面向对象总结/","excerpt":"","text":"Java面向对象总结java是一门面向对象的语言 面向对象三大特征：封装、继承、多态 一、类和对象类：对现实中的事物描述 对象：就是这类事物的某一个体 成员变量+动态方法=对象 创建对象：类名 对象名 = new 类名() 1Student a = new Student(); 使用对象：对象.属性 / 对象.方法名() 1a.tell(); 成员变量与局部变量成员变量：在类中定义，用来描述对象将要有什么。（作用域在整个类内部都是可见的） 局部变量：在类的方法中定义，在方法中临时保存数据。（作用域仅限于定义它的方法） 区别： ①作用域不用 ②两类变量同名时，局部变量的优先级更高 ③初始值不同：Java会给成员变量一个初始值，不会给局部变量赋予初始值 构造方法定义在Java中的一个用来初始化对象的方法。 ①使用new+构造方法 创建一个新的对象。 ②名称与类名相同且没有返回值。 ③当没有指定构造方法时，系统会自动添加无参的构造方法。 ④当有指定构造方法时，无论是有参、无参的构造方法，都不会自动添加无参的构造方法。 ⑤构造方法可重载：方法名相同，但参数不同，调用时会自动根据不同的参数选择相应的方法。 ⑥构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值（在构造函数中增加判断）。 static静态变量（也称类成员）①它属于整个类所有，而不是某个对象所有，被类的所有对象所共享。 ②静态成员可使用类名直接访问，也可以使用对象名进行访问。 ③静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收。 static静态方法（也称类方法）①静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。 ②如果系统在静态方法中调用非静态变量，可通过创建类的对象，然后通过对象来访问非静态变量。 ③在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。 ④静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。 初始化块①普通初始化块 { xxx = xxx; } ②静态初始化块 static { xxx = xxx; } ③执行顺序：静态初始化块最先被执行–&gt;普通初始化块–&gt;构造方法 二、封装比如电视机，你是看不到内部的东西，但可以使用遥控器就调用它。 1.提高数据的安全性。 2.操作简单 3.隐藏了实现 使用private修饰需要封装的属性，用set和get设置和获取属性。 Java中的包①作用：管理Java文件，解决同名文件的冲突 ②必须放在Java源程序的第一行，包名间用”.”号隔开 ③包的使用：可以通过import关键字在某个文件中使用其它文件中的类，Java包的命名是全小写字母 private ：本类访问（私有类） default ：表示默认，不仅本类访问，而且是同包可见。 Protected：同包可见+不同包的子类可见 Public ：表示所有的地方均可见 Java中this关键字 代表当前对象 this.属性：操作当前对象的属性 this.方法：调用当前对象的方法 内部类： 三、继承 class 子类 extends 父类{ } 子类只能有一个父类 方法的重写： ① 子类可重写从父类继承的方法，当调用方法时会优先调用子类的方法。 ② 返回值类型、方法名、参数类型及个数 都要与父类继承的方法相同，才叫方法的重写。 继承要注意的事项： 千万不要为了减少重复代码而去继承，只有真正存在着继承关系的时候才去继承。 父类私有的成员不能被继承。 父类的构造函数不能被继承。 创建子类对象时默认会先调用父类无参的构造函数。 super 关键字是代表父类空间的引用 重写：目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。 4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。 Exception(最坏) RuntimeException(小坏) 可以通过super关键字进行父类的重写函数的调用。 instanceof关键字 instanceof关键字的作用：判断一个对象是否属于指定的类别。 抽象类 ①应用场景：在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。 ②从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 ③限制规定子类必须实现某些方法，但不关注实现细节。 ④ abstract定义抽象类 ⑤abstract定义抽象方法，只有声明，不需要实现 ⑥包含抽象方法的类是抽象类 ⑦抽象类中可以包含普通的方法，也可以没有抽象方法 ⑧抽象类不能直接创建，可以定义引用变量 接口 接口的定义格式： interface 接口名{ } 接口要注意的事项 ： 接口是一个特殊的类。 接口的成员变量默认的修饰符为： public static final。那么也就是说接口中的成员变量都是常量。 接口中的方法都是抽象的方法，默认的修饰符为： public abstract。 接口不能创建对象。 接口是没有构造方法的。 接口是给类去实现使用的，非抽象类实现一个接口的时候，必须要把接口中所有方法全部实现。 实现接口的格式： class 类名 implements接口名{ } interface A{ int x = 1; public int getArea(); } class Demo implements A{ public int getArea(){ return A.x; } } 多态 多态：一个对象具备多种形态。(父类的引用类型变量指向了子类的对象或者是接口的引用类型变量指向了接口实现类的对象) 多态的前提：必须存在继承或者实现 关系。 Animal a = new dog(); 多态要注意的细节： 多态情况下，子父类存在同名的成员变量时，访问的是父类的成员变量。 多态情况下，子父类存在同名的非静态的成员函数时，访问的是子类的成员函数。 多态情况下，子父类存在同名的静态的成员函数时，访问的是父类的成员函数。 多态情况下，不能访问子类特有的成员。 总结：多态情况下，子父类存在同名的成员时，访问的都是父类的成员，除了在同名非静态函数时才是访问子类的。 多态的应用： 多态用于形参类型的时候，可以接收更多类型的数据 。 多态用于返回值类型的时候，可以返回更多类型的数据。 多态的好处： 提高了代码的拓展性。","categories":[],"tags":[]},{"title":" Java 数组","slug":"Java-数组","date":"2017-11-14T15:09:28.000Z","updated":"2017-11-23T06:31:32.105Z","comments":true,"path":"2017/11/14/Java-数组/","link":"","permalink":"http://yoursite.com/2017/11/14/Java-数组/","excerpt":"数组 数组是相同类型的数据按顺序组成的一种引用数据类型 数组是用来存储固定大小的同类型元素。","text":"数组 数组是相同类型的数据按顺序组成的一种引用数据类型 数组是用来存储固定大小的同类型元素。 数组声明 语法格式 数据类型[] 数组名;int [] a; 创建数组 Java语言使用new操作符来创建数组int[] myArray =new int[10] ;还可以使用如下的方式创建数组int[] myArray = {1,2,3,4,5,6,7,8,9,10};注意：数组长度必须指定 实例 123456789101112131415161718192021222324252627282930313233343536373839 11/23/2017 2:30:00 PM 11/23/2017 2:30:07 PM int[] a = new int[5];//使用Scanner 从键盘获取值Scanner sc=new Scanner(System.in);//分别存储输入的数for(int i=0;i&lt;a.length;i++)&#123; System.out.println(&quot;请输入元素&quot;+(i+1)); a[i]=sc.nextInt();&#125;System.out.println(&quot;原数组排序：&quot;); //输出数组的排序for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;);&#125;//冒泡排序int temp;for(int i=0;i&lt;a.length-1;i++) &#123; for(int j=0;j&lt;a.length-i-1;j++) &#123; if(a[j]&lt;a[j+1]) &#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125;&#125;System.out.println();for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i]+&quot; &quot;);&#125;System.out.println();for(int n:a) &#123; System.out.print(n+&quot; &quot;);&#125;","categories":[],"tags":[]}]}